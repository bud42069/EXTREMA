from fastapi import APIRouter, HTTPException, WebSocket, WebSocketDisconnect

from ..services.signal_engine import mark_candidates, micro_confirm
from ..utils.store import get_df
from ..utils.logging import get_logger

router = APIRouter()
logger = get_logger(__name__)

# WebSocket client management
websocket_clients: list[WebSocket] = []


@router.get("/latest")
def latest_signal(
    atr_min: float = 0.6,
    volz_min: float = 1.0,
    bbw_min: float = 0.005,
    breakout_atr_mult: float = 0.5,
    vol_mult: float = 1.5,
    confirm_window: int = 6
):
    df = get_df()
    if df is None:
        raise HTTPException(400, "No data loaded")
    df2 = mark_candidates(df, atr_min, volz_min, bbw_min)

    for i in range(len(df2)-1, -1, -1):
        is_long = bool(df2.at[i, "cand_long"])
        is_short = bool(df2.at[i, "cand_short"])
        side = "long" if is_long else ("short" if is_short else None)
        if not side:
            continue
        j = micro_confirm(df2, i, side, confirm_window, breakout_atr_mult, vol_mult)
        if j is None:
            continue
        entry = float(df2.at[j, "close"])
        atr5 = float(df2.at[i, "ATR14"] * (5/14))
        if side == "long":
            sl = float(min(df2.at[i, "low"], entry - 0.9*atr5))
            r = entry - sl
            tp1, tp2, tp3 = entry + 1.0*r, entry + 2.0*r, entry + 3.0*r
        else:
            sl = float(max(df2.at[i, "high"], entry + 0.9*atr5))
            r = sl - entry
            tp1, tp2, tp3 = entry - 1.0*r, entry - 2.0*r, entry - 3.0*r
        return {
            "side": side,
            "extremum_index": i,
            "confirm_index": j,
            "entry": entry,
            "sl": float(sl),
            "tp1": float(tp1),
            "tp2": float(tp2),
            "tp3": float(tp3),
            "trail_atr_mult": 0.5
        }
    return {"message": "no confirmed signal"}


@router.websocket("/stream")
async def websocket_signals(websocket: WebSocket):
    """
    WebSocket endpoint for real-time signal streaming.
    Clients connect here to receive live signals as they are generated.
    """
    await websocket.accept()
    websocket_clients.append(websocket)
    logger.info(f"WebSocket client connected. Total clients: {len(websocket_clients)}")
    
    try:
        # Send initial connection success
        await websocket.send_json({
            'type': 'connected',
            'message': 'WebSocket connection established'
        })
        
        # Keep connection alive and handle ping/pong
        while True:
            try:
                data = await websocket.receive_text()
                if data == 'ping':
                    await websocket.send_text('pong')
            except WebSocketDisconnect:
                logger.info("WebSocket client disconnected")
                break
            except Exception as e:
                logger.error(f"WebSocket error: {e}")
                break
    
    finally:
        if websocket in websocket_clients:
            websocket_clients.remove(websocket)
            logger.info(f"Client removed. Remaining: {len(websocket_clients)}")


async def broadcast_signal(signal_data: dict):
    """
    Broadcast a signal to all connected WebSocket clients.
    Called when a new signal is generated by the live monitor.
    """
    disconnected_clients = []
    for client in websocket_clients:
        try:
            await client.send_json({
                'type': 'new_signal',
                'data': signal_data
            })
        except Exception as e:
            logger.error(f"Error sending to WebSocket client: {e}")
            disconnected_clients.append(client)
    
    # Clean up disconnected clients
    for client in disconnected_clients:
        if client in websocket_clients:
            websocket_clients.remove(client)